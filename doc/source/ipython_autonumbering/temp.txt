[u'.. _users-guide\n\n************\nUser\'s Guide\n************\n\n``ivy`` is designed to be used both as a library and interactively, in\nthe IPython shell.  `IPython <http://ipython.scipy.org>`_ is an\nenhanced Python interpreter designed for interactive and exploratory\nscientific computing.\n\nThis `screencast <http://vimeo.com/23646898>`_ demonstrates some basic\nconcepts:\n\n.. raw:: html\n\n    <iframe\n     src="http://player.vimeo.com/video/23646898?title=0&amp;byline=0&amp;portrait=0"\n     width="400" height="208" frameborder="0"></iframe>\n\n\n    <p><a href="http://vimeo.com/23646898" target="_blank">Watch in\n     full resolution (opens in new window)</a></p>\n\nQuickstart\n==========\n\nStarting the shell\n------------------\n\nThe ``-pylab`` option starts IPython in a mode that imports a number\nof functions from matplotlib and numpy, and allows interactive\nplotting.\n\n.. code-block:: bash\n\n    $ ipython -pylab\n\nIn interactive mode, ``ivy`` provides some useful shortcut functions\n(e.g., readtree, readaln, treefig, alnfig) that you will typically\nwant to import as follows.\n\n.. sourcecode:: ipython\n\n    In [1]: from ivy.interactive import *\n\nViewing a tree\n--------------\n\nAssuming you have started the shell,\n\n.. sourcecode:: ipython\n\n   In [2]: s = "examples/primates.newick"\n   In [3]: fig = treefig(s)\n\nHere, the variable *s* can be a newick string, the name (path) of a\nfile containing a newick tree, or an open file containing a newick\nstring.  Note that file paths are completed dynamically in ipython by\nhitting the <TAB> key, making it easy to find files with little\ntyping.\n\nA new window should appear, controlled by the variable *fig*.  View\nthe help for *fig*::\n\n   fig?\n\nTrees in Ivy\n=============\n\nIvy does not have a tree class per se; rather trees in Ivy exist as collections\nof nodes. In Ivy, a Node is a class that contains information about a node.\nNodes are rooted and recursively contain their children. Functions\nin Ivy act directly on Node objects. Nodes support Python idioms such as ``in``,\n``[``, iteration, etc. This guide will cover how to read, view, navigate, modify,\nand write trees in Ivy.\n\nReading\n-------\n\nYou can read in trees using Ivy\'s ``tree.read`` function. This function supports\nnewick and nexus files. The tree.read function can take a file name, a file\nobject, or a Newick string as input. The output of this function is the root\nnode of the tree.\n\n.. sourcecode:: ipython\n\n    In [*]: import ivy\n    In [*]: f = open("examples/primates.newick")\n    In [*]: r = ivy.tree.read(f)\n    In [*]: f.close()\n    In [*]: r = ivy.tree.read("examples/primates.newick")\n    In [*]: r = ivy.tree.read(\n                "((((Homo:0.21,Pongo:0.21)A:0.28,Macaca:0.49)"\n                "B:0.13,Ateles:0.62)C:0.38,Galago:1.00)root;")\n    In [*]: # These three methods are identical\n\nYou can copy a read tree using the ``copy`` method on the root node. Node\nobjects are mutable, so this method is preferred over ``r2 = r`` if you want\nto create a deep copy.\n\n.. sourcecode:: ipython\n\n    In [*]: r2 = r.copy(recurse=True) # If recurse=False, won\'t copy children etc.\n\n.. warning::\n\n    As of now, the copy function does not produce a complete tree: the nodes are not\n    properly connected to each other\n\n.. sourcecode:: ipython\n\n    In [*]: print r2["A"].parent\n    None\n\nViewing\n-------\n\nThere are a number of ways you can view trees in Ivy. For a simple display\nwithout needing to create a plot, Ivy can create ascii trees that can be\nprinted to the console.\n\n.. sourcecode:: ipython\n\n    In [*]: print r.ascii # You can use the ascii method on root nodes.\n                                   ---------+ Homo\n                          --------A+\n                 --------B+        ---------+ Pongo\n                 :        :\n        --------C+        ------------------+ Macaca\n        :        :\n    root+        ---------------------------+ Ateles\n        :\n        ------------------------------------+ Galago\n\nFor a more detailed and interactive tree, Ivy can create a plot using\n``Matplotlib``. More detail about visualization using Matplotlib will follow\nlater in the guide.\n\n.. sourcecode:: ipython\n\n    In [*]: import ivy.vis\n    In [*]: fig = ivy.vis.tree.TreeFigure(r)\n    In [*]: fig.show()\n\n.. image:: _images/primate_mpl.png\n\n\nYou can also create a plot using ``Bokeh``.\n\n.. sourcecode:: ipython\n\n    In [*]: import ivy.vis.bokehtree\n    In [*]: fig2 = ivy.vis.bokehtree.BokehTree(r)\n    In [*]: fig2.drawtree()\n\n.. image:: _images/primate_bokeh.png\n\n.. TODO: embed plot images\n\nNavigating\n----------\n\nA node in Ivy is a container. It recursively contains its descendants,\nas well as itself. You can navigate a tree using the Python idioms that\nyou are used to.\n\nLet\'s start by iterating over all of the children contained within the root\nnode. By default, iteration over a node happens in preorder sequence, starting\nwith the root node.\n\n.. sourcecode:: ipython\n\n    In [*]: len(r)\n    Out[*]: 9 # Length of a node = number of descendants + self\n    In [*]: for node in r:\n                print node # Default is preorder sequence\n    Node(139624003155728, root, \'root\')\n    Node(139624003155536, \'C\')\n    Node(139624003155600, \'B\')\n    Node(139624003155664, \'A\')\n    Node(139624003155792, leaf, \'Homo\')\n    Node(139624003155856, leaf, \'Pongo\')\n    Node(139624003155920, leaf, \'Macaca\')\n    Node(139624003155984, leaf, \'Ateles\')\n    Node(139624003156048, leaf, \'Galago\')\n    In [*]: for node in r.preiter:\n                print node # Same as above\n    Node(140144824314320, root, \'root\')\n    Node(140144824314384, \'C\')\n    Node(140144824314448, \'B\')\n    Node(140144824314512, \'A\')\n    Node(140144824314576, leaf, \'Homo\')\n    Node(140144824314192, leaf, \'Pongo\')\n    Node(140144824314256, leaf, \'Macaca\')\n    Node(140144824314640, leaf, \'Ateles\')\n    Node(140144824314704, leaf, \'Galago\')\n    In [*]: for node in r.postiter:\n                print node # Nodes in postorder sequence.\n    Node(140144824314576, leaf, \'Homo\')\n    Node(140144824314192, leaf, \'Pongo\')\n    Node(140144824314512, \'A\')\n    Node(140144824314256, leaf, \'Macaca\')\n    Node(140144824314448, \'B\')\n    Node(140144824314640, leaf, \'Ateles\')\n    Node(140144824314384, \'C\')\n    Node(140144824314704, leaf, \'Galago\')\n    Node(140144824314320, root, \'root\')\n\n\nWe can access internal nodes using square brackets on the root node (or other\nancestor node).\n\n.. sourcecode:: ipython\n\n    In [*]: r["C"] # You can use the node label\n    Out[*]: Node(139624003155536, \'C\')\n    In [*]: r[139624003155536] # The node ID\n    Out[*]: Node(139624003155536, \'C\')\n    In [*]: r[1] # Or the index of the node in preorder sequence\n    Out[*]: Node(139624003155536, \'C\')\n\nWe can access the information a node has about which other nodes it is\nconnected to using the ``children`` and ``parent`` attributes, which return\nthe nodes directly connected to the current node. The ``descendants`` method, on\nthe other hand, recursively lists all descendants of a node (not including\nthe node itself)\n\n.. sourcecode:: ipython\n\n    In [*]: r["C"].children\n    Out[*]: [Node(139624003155600, \'B\'), Node(139624003155984, leaf, \'Ateles\')]\n    In [*]: r["B"].parent\n    Out[*]: Node(139624003155536, \'C\')\n    In [*]: r["B"].descendants()\n    Out[*]:\n    [Node(139624003155664, \'A\'),\n     Node(139624003155792, leaf, \'Homo\'),\n     Node(139624003155856, leaf, \'Pongo\'),\n     Node(139624003155920, leaf, \'Macaca\')]\n\nWe can search nodes using regular expressions with the Node grep method.\nWe can also grep leaf nodes and internal nodes specifically.\n\n.. sourcecode:: ipython\n\n    In [*]: r.grep("A") # By default, grep ignores case\n    Out[*]:\n    [Node(139624003155664, \'A\'),\n     Node(139624003155920, leaf, \'Macaca\'),\n     Node(139624003155984, leaf, \'Ateles\'),\n     Node(139624003156048, leaf, \'Galago\')]\n    In [*]: r.grep("A", ignorecase = False)\n    Out[*]: [Node(139624003155664, \'A\'), Node(139624003155984, leaf, \'Ateles\')\n    In [*]: r.lgrep("A", ignorecase = False) # Limit our search to leaves\n    Out[*]: [Node(140144824314640, leaf, \'Ateles\')]\n    In [*]: r.bgrep("Homo", ignorecase = False) # Limit our search to branches\n    Out[*]: []\n\n\n\n\n\n\nWe can also search for nodes that match a certain criterion using the\n``find`` method. ``find`` takes a function that takes a node as its\nfirst argument and returns a ``bool``.\n\n.. sourcecode:: ipython\n\n    In [*]: def three_or_more_decs(node):\n                return len(node) >= 4\n    In [*]: r.find(three_or_more_decs) # Find returns a generator\n    Out[*]: <generator object find at 0x7efcbf498730>\n    In [*]: r.findall(three_or_more_decs) # Findall returns a list\n    Out[*]:\n    [Node(139624003155728, root, \'root\'),\n     Node(139624003155536, \'C\'),\n     Node(139624003155600, \'B\')]\n\n\n\nTesting\n-------\n\nWe can test many attributes of a node in Ivy.\n\nWe can test whether a node contains another node\n\n.. sourcecode:: ipython\n\n    In [*]: r["A"] in r["C"]\n    Out[*]: True\n    In [*]: r["C"] in r["A"]\n    Out[*]: False\n    In [*]: r["C"] in r["C"]\n    Out[*]: True # Nodes contain themselves\n\nWe can test if a node is the root\n\n.. sourcecode:: ipython\n\n    In [*]: r.isroot\n    Out[*]: True\n    In [*]: r["C"].isroot\n    Out[*]: False\n\nWe can test if a node is a leaf\n\n.. sourcecode:: ipython\n\n    In [*]: r.isleaf\n    Out[*]: False\n    In [*]: r["Homo"].isleaf\n    Out[*]: True\n\nWe can test if a group of leaves is monophyletic\n\n.. sourcecode:: ipython\n\n    In [*]: r.ismono(r["Homo"], r["Pongo"])\n    Out[*]: True\n    In [*]: r.ismono(r["Homo"], r["Pongo"], r["Galago"])\n    Out[*]: False\n\n.. warning::\n    `ismono` does not return an error if an internal node is given to it,\n    but it does produce undesired results.\n\nModifying\n---------\n\nThe Ivy Node object has many methods for modifying a tree in place.\n\n\nRemoving\n~~~~~~~~\n\nThere are two main ways to remove nodes in Ivy; collapsing and pruning.\n\nCollapsing removes a node and attaches its descendants to the node\'s parent.\n\n.. sourcecode:: ipython\n\n    In [*]: r["A"].collapse()\n    In [*]: print r.ascii()\n                                ------------+ Macaca\n                                :\n                    -----------B+-----------+ Homo\n                    :           :\n        -----------C+           ------------+ Pongo\n        :           :\n    root+           ------------------------+ Ateles\n        :\n        ------------------------------------+ Galago\n\nPruning removes a node and its descendants\n\n.. sourcecode:: ipython\n\n    In [*]: cladeB = r["B"] # Store this node: we will add it back later\n    In [*]: r["B"].prune()\n    In [*]: print r.ascii()\n        -----------------C+-----------------+ Ateles\n    root+\n        ------------------------------------+ Galago\n\nYou can see that the tree now has a \'knee\': clade C only has one child and\ndoes not need to exist on the tree. We can remove it with another method of\nremoving nodes: excising. Excising removes a node from between its parent\nand its single child.\n\n.. sourcecode:: ipython\n\n    In [*]: r["C"].excise()\n    In [*]: print r.ascii()\n        -------------------------------------+ Galago\n    root+\n        -------------------------------------+ Ateles\n\nIt is important to note that although the tree has changed, the nodes in the\ntree retain some of their original attributes, including their indices:\n\n.. sourcecode:: ipython\n\n    In [*]: r[0]\n    Out[*]: Node(140144821291920, root, \'root\')\n    In [*]: r[1] # Node 1 ("C") no longer exists\n    ---------------------------------------------------------------------------\n    IndexError                                Traceback (most recent call last)\n\n    IndexError: 1\n    In [*]: r[7] # You can access existing nodes with their original indices\n    Out[*]: Node(140144821292368, leaf, \'Ateles\')\n\nTo recap:\n#. ``collapse`` removes a node and adds its descendants to its parent\n#. ``prune`` removes a node and also removes its descendants\n#. ``excise`` removes \'knees\'\n\nAdding\n~~~~~~\n\nOur tree is looking a little sparse, so let\'s add some nodes back in. There\nare a few methods of adding nodes in Ivy. We will go over ``biscect``, ``add_child``, and ``graft``\n\nBisecting creates a \'knee\' node halfway between a parent and a child.\n\n.. sourcecode:: ipython\n\n    In [*]: r["Galago"].bisect_branch()\n    Out[*]: Node(140144821654480)\n    In [*]: print r.ascii\n        ------------------------------------+ Ateles\n    root+\n        ------------------+-----------------+ Galago\n\nWe now have a brand new node. We can set some of its attributes, including its\nlabel.\n\nNote: we `cannot` access this new node by using node indicies (that is,\nr[1], etc.). We also cannot use its label because it has none. We\'ll access\nit using its ID instead (if you\'re following along, your ID will be different).\n\n.. sourcecode:: ipython\n\n    In [*]: r[140144821654480].label = "N"\n\nNow let\'s add a node as a child of N. We can do this using the ``add_child`` method.\n\n.. sourcecode:: ipython\n\n    In [*]: r["N"].add_child(cladeB["Homo"])\n    In [*]: print r.ascii()\n        ------------------------------------+ Ateles\n    root+\n        :                 ------------------+ Galago\n        -----------------N+\n                          ------------------+ Homo\n\nWe can also add nodes with ``graft``. ``graft`` adds a node as a sibling to the\ncurrent node. In doing so, it also adds a new node as parent to both nodes.\n\n.. sourcecode:: ipython\n\n    In [*]: r["Ateles"].graft(cladeB["Macaca"])\n    In [*]: r["Galago"].graft(cladeB["Pongo"])\n    In [*]: print r.ascii()\n                    ------------------------+ Homo\n        -----------N+\n        :           :           ------------+ Galago\n        :           ------------+\n    root+                       ------------+ Pongo\n        :\n        :                       ------------+ Ateles\n        ------------------------+\n                                ------------+ Macaca\n\n\nTo recap:\n\n#. ``bisect_branch`` adds \'knees\'\n#. ``add_child`` adds a node as a child to the current node\n#. ``graft`` adds a node as a sister to the current node, and also adds a parent.\n\n\nLadderizing\n~~~~~~~~~~~\n\nLadderizing non-destructively changes the tree so that it has a nicer-looking\noutput when drawn. It orders the clades by size.\n\n.. sourcecode:: ipython\n\n    In [*]: r.ladderize()\n    In [*]: print r.ascii()\n                                ------------+ Ateles\n        ------------------------+\n        :                       ------------+ Macaca\n    root+\n        :           ------------------------+ Homo\n        -----------N+\n                    :           ------------+ Galago\n                    ------------+\n                                ------------+ Pongo\n\n\nRerooting\n~~~~~~~~~\n\n.. warning::\n    Currently does not work properly.\n\n.. sourcecode:: ipython\n\n    In [*]: r.reroot(r["N"])\n    In [*]: r.descendants() # Missing descendants\n    Out[*]:\n    [Node(140144821839696),\n     Node(140144821839120, leaf, \'Ateles\'),\n     Node(140144821839056, leaf, \'Macaca\')]\n    In [*]: print r.ascii() # Raises a KeyError\n\nWriting\n-------\n\nOnce you are done modifying your tree, you will probably want to save it.\nYou can save your trees with the ``write`` function. This function\ntakes a root node and an open file object as inputs. This function can\ncurrently only write in newick format.\n\n\n.. sourcecode:: ipython\n\n    In [*]: f = open("examples/primates_mangled.newick", "w")\n    In [*]: ivy.tree.write(r, outfile = f)\n    In [*]: f.close()\n\n\nUsing Treebase\n==============\n\n``ivy`` has functions to pull trees from `Treebase <http://treebase.org/treebase-web/about.html;jsessionid=5B7D6A265E17EFAB9565327D3A78CD4B>`_.\n\n\nFetching the study\n------------------\n\nIf you have an id for a study on treebase, you can fetch the study and\naccess the trees contained within the study.\n\n.. sourcecode:: ipython\n\n    In [*]: import ivy\n    In [*]: from ivy.treebase import fetch_study\n    In [*]: study_id = "1411" # The leafy cactus genus Pereskia\n    In [*]: e = fetch_study(study_id, \'nexml\') # e is an lxml etree\n\n\nAccessing the tree\n------------------\n\nYou can parse the output of fetch_study using the parse_nexml function,\n then access the tree(s) contained within the study.\n\n.. sourcecode:: ipython\n\n    In [*]: from ivy.treebase import parse_nexml\n    In [*]: x = parse_nexml(e) # x is an ivy Storage object\n    In [*]: r = x.trees[0].root\n    In [*]: from ivy.interactive import treefig\n    In [*]: fig = treefig(r)\n\n\n\nVisualization with Matplotlib\n=============================\n\n``ivy`` supports interactive tree visualization with Matplotlib. \n\nDisplaying a tree is very simple\n\n.. sourcecode:: ipython\n\n    In [*]: from ivy.interactive import *\n    In [*]: r = ivy.tree.read("examples/primates.newick")\n    In [*]: fig = treefig(r)\n\n.. image:: _images/visualization_1.png\n\nA tree figure by default consists of the tree with clade and leaf\nlabels and a navigation toolbar. The navigation toolbar allows zooming and\npanning. Panning can be done by clicking with the middle mouse button, using\nthe arrow keys, or using the pan tool on the toolbar. Zooming can be done\nusing the scroll wheel, the plus and minus keys, or the \'zoom to rectangle\'\ntool in the toolbar. Press t to return default zoom level.\n\nLarger trees are shown with a split overview pane as well, which can be toggled\nwith the ``toggle_overview`` method.\n\n.. sourcecode:: ipython\n\n    In [*]: fig.toggle_overview()\n\n.. image:: _images/visualization_2.png\n\nYou can retrieve information about a node or group of nodes by selecting\nthem (selected nodes have green circles on them) \nand accessing the ``selected`` nodes\n\n.. sourcecode:: ipython\n\n    In [*]: fig.selected\n    Out [*]: \n    [Node(139976891981456, leaf, \'Homo\'),\n     Node(139976891981392, \'A\'),\n     Node(139976891981520, leaf, \'Pongo\')]\n\n.. image:: _images/visualization_3.png\n\n\nYou can also select nodes from the command line. Entering an internal node will\nselect that node and all of its descendants.\n\n.. sourcecode:: ipython\n\n    In [*]: fig.select_nodes(r["C"])\n\n.. image:: _images/visualization_4.png\n\nYou can highlight certain branches using the ``highlight`` method. Again, \nentering an internal node will highlight that node and its descendants. This\nalso highlights the branches on the overview.\n\n.. sourcecode:: ipython\n\n    In [*]: fig.highlight(r["B"])\n\n.. image:: _images/visualization_5.png\n\nYou can also decorate the tree with various symbols using the ``decorate``\nmethod. ``decorate`` can be called with any function from ``ivy.symbols``.\n\n.. sourcecode:: ipython\n\n    In [*]: import ivy.vis.symbols\n    In [*]: fig.redraw() # This clears the plot\n    In [*]: fig.decorate(ivy.vis.symbols.circles, r.leaves(), \n            colors = ["red", "orange", "yellow", "green", "blue"])\n\n.. image:: _images/visualization_6.png\n\n\nPerforming analyses\n===================\n\n``ivy`` has many tools for performing analyses on trees. Here we will cover\na few analyses you can perform.\n\nPhylogenetically Independent Contrasts\n--------------------------------------\n\nYou can perform PICs using ``ivy``\'s ``PIC`` function. This function takes a\nroot node and a dictionary mapping node labels to character traits as inputs\nand outputs a dictionary mappinginternal nodes to tuples containing ancestral\nstate, its variance (error), the contrast, and the contrasts\'s variance.\n\nNote: This function requires that the root node have a length that is not none\nNote: this function currently cannot handle polytomies.\n\n.. sourcecode:: ipython\n\n    In [*]: import ivy\n    In [*]: r = ivy.tree.read("examples/primates.newick")\n    In [*]: r.length = 0.0 # Setting the root length to 0\n    In [*]: char1 = {\n                    "Homo": 4.09434,\n                    "Pongo": 3.61092,\n                    "Macaca": 2.37024,\n                    "Ateles": 2.02815,\n                    "Galago": -1.46968\n                    }\n    In [*]: c = ivy.contrasts.PIC(r, char1)\n    In [*]: for k,v in c.items():\n                print k.label, v\n    root (1.1837246133953971, 0.3757434703904836, 4.25050357912179, 1.6019055509527755)\n    A (3.85263, 0.385, 0.48341999999999974, 0.42)\n    B (3.2003784000000004, 0.3456, 1.48239, 0.875)\n    C (2.78082357912179, 0.6019055509527755, 1.1722284000000003, 0.9656)\n\n\nLineages Through Time\n---------------------\n\n``ivy`` has functions for computing LTTs. The ``ltt`` function takes a root\nnode as input and returns a tuple of 1D-arrays containing the results of\ntimes and diverisities.\n\nNote: The tree is expected to be an ultrametric chromogram (extant leaves,\nbranch lengths proportional to time).\n\n.. sourcecode:: ipython\n\n    In [*]: import ivy\n    In [*]: r = ivy.tree.read("examples/primates.newick")\n    In [*]: v = ivy.ltt(r)\n    In [*]: print r.ascii()\n                                   ---------+ Homo\n                          --------A+\n                 --------B+        ---------+ Pongo\n                 :        :\n        --------C+        ------------------+ Macaca\n        :        :\n    root+        ---------------------------+ Ateles\n        :\n        ------------------------------------+ Galago\n    In [*]: for i in l:\n                print i\n    [ 0.    0.38  0.51  0.79]\n    [ 1.  2.  3.  4.]\n\n\nYou can plot your results using ``Matplotlib``.\n\n\n.. sourcecode:: ipython\n\n    In [*]: import matplotlib.pyplot as plt\n    In [*]: plt.step(v[0], v[1])\n    In [*]: plt.margins(.2, .2)\n    In [*]: plt.xlabel("Time"); plt.ylabel("Lineages"); plt.title("LTT")\n    In [*]: plt.show()\n\n.. image:: _images/ltt.png\n\n\nPhylorate plot\n--------------\n\nBy accessing R libraries using `rpy2 <http://rpy.sourceforge.net/>`_, we can use\nthe functions in the `BAMMtools <https://cran.r-project.org/web/packages/BAMMtools/index.html>`_\nR library to generate phylorate plots.\n\nUsing the whales dataset provided with BAMMtools:\n\n.. sourcecode:: ipython\n\n    In [*]: e = "whaleEvents.csv" # Event data created with BAMM\n    In [*]: treefile = "whales.tre"\n\n\n\n\n\n\n\n\n\n\n\n\n']
